# OCP 1

1)
A nested classявляется классом, который определен в другом классе.
Вложенный класс, который не staticназывается, называется inner class. 

Существует четыре типа вложенных классов:

•	Внутренний класс-член - это класс, определенный на том же уровне, что и переменные экземпляра. Это не статично. 
Часто это просто называется внутренним классом без явного указания типа.
•	Локальный внутренний класс определяется внутри метода.
•	Анонимный внутренний класс - это особый случай локального внутреннего класса, у которого нет имени.
•	Статический вложенный класс - это staticкласс, который определен на том же уровне, что и staticпеременные.

Внутренние классы-члены требуют использования экземпляра внешнего класса.
Они могут получить доступ к privateчленам этого внешнего класса.

Локальные внутренние классы - это классы, определенные в методе. Они также могут получить доступ к privateчленам внешнего класса.
Локальные внутренние классы также могут обращаться к finalлокальным переменным или эффективно обрабатывать их.

Анонимные внутренние классы - это особый тип локального внутреннего класса, который не имеет имени.
Анонимные внутренние классы должны расширять ровно один класс по имени или реализовывать ровно один interface.

Статические вложенные классы могут существовать без экземпляра внешнего класса.


Есть несколько преимуществ использования внутренних классов. Они могут инкапсулировать вспомогательные классы, ограничивая их содержащим классом.
Они могут упростить создание класса, который будет использоваться только в одном месте. Они могут сделать код проще для чтения. 
Они также могут затруднить чтение кода при неправильном использовании. К сожалению, экзамен проверяет эти крайние случаигде программисты не будут использовать вложенный класс.
Этот раздел охватывает все четыре типа вложенных классов.

.class Файлы для внутренних классов
Компиляция Outer.java класса, с которым мы работали, создает два файла классов. Outer.classты должен был ожидать.
Для внутреннего класса компилятор создает Outer$Inner.class. Вам не нужно знать этот синтаксис для экзамена.
Мы упоминаем об этом, чтобы вы не удивились, увидев файлы $в ваших каталогах. Вы должны понимать, что создано несколько файлов классов.
Внутренние классы могут иметь те же имена переменных, что и внешние классы. Существует особый способ звонка, thisчтобы сказать, к какому классу вы хотите получить доступ.
Вы также не ограничены только одним внутренним классом. Пожалуйста, никогда не делайте этого в написанном вами коде.
Вот как вложить несколько классов и получить доступ к переменной с одинаковым именем в каждом:

1:    public class A {
2:       private int x = 10;
3:       class B {
4:         private int x = 20;
5:         class C {
6:            private int x = 30;
7:            public void allTheX() {
8:               System.out.println(x);            // 30
9:               System.out.println(this.x);       // 30
10:              System.out.println(B.this.x);     // 20
11:              System.out.println(A.this.x);    // 10
12:       } } }
13:      public static void main(String[] args) {
14:         A a = new A();
15:         A.B b = a.new B();
16:         A.B.C c = b.new C();
17:         c.allTheX();
18:   }}
Да, этот код заставляет нас тоже съеживаться. У него есть два вложенных класса. Строка 14 создает экземпляр самого внешнего.
Строка 15 использует неуклюжий синтаксис для создания экземпляра a B. Обратите внимание на тип A.B. Мы могли бы написать Bкак тип,
потому что это доступно на уровне члена B. Java знает, где его искать. В строке 16 мы создаем экземпляр a C. На этот раз A.B.Cтип необходимо указать.
Cслишком глубоко для Java, чтобы знать, где искать. Затем строка 17 вызывает метод on c.
Строки 8 и 9 - это тип кода, который мы привыкли видеть. Они ссылаются на переменную экземпляра в текущем классе - который объявлен в строке 6, чтобы быть точным.
Линия 10 использует thisособым образом. Мы все еще хотим переменную экземпляра. Но на этот раз мы хотим получить значение Bкласса, которое является переменной в строке 4.
Строка 11 делает то же самое для класса A, получая переменную из строки 2.

2)  Методы toString(), equals()и hashCode()реализуются в Objectс , что классы могут переопределить , чтобы изменить их поведение

toString()используется для обеспечения удобочитаемого представления объекта.

equals()используется, чтобы указать, какие переменные экземпляра должны рассматриваться на равенство.
equals()требуется вернуть, falseесли переданный объект имеет nullили имеет неправильный тип.

hashCode()используется для обеспечения группировки в некоторых коллекциях.
hashCode()требуется вернуть тот же номер при вызове с объектами, которые equals(). 

