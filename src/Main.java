public class Main {
       private int x = 10;
       class B {
         private int x = 20;
         class C {
            private int x = 30;
            public void allTheX() {
                               System.out.println(x);            // 30
                               System.out.println(this.x);       // 30
                               System.out.println(B.this.x);     // 20
                               System.out.println(Main.this.x);  // 10
                       } } }
      public static void main(String[] args) {
          Main a = new Main();
          Main.B b = a.new B();
          Main.B.C c = b.new C();
          c.allTheX();
           }}

          //30
          //30
          //20
          //10
// Внутренние классы могут иметь те же имена переменных, что и внешние классы.
// Существует особый способ звонка, thisчтобы сказать, к какому классу вы хотите получить доступ.
// Вы также не ограничены только одним внутренним классом. Пожалуйста, никогда не делайте этого в написанном вами коде.
// Вот как вложить несколько классов и получить доступ к переменной с одинаковым именем в каждом:
//
//1:    public class A {
//2:       private int x = 10;
//3:       class B {
//4:         private int x = 20;
//5:         class C {
//6:            private int x = 30;
//7:            public void allTheX() {
//8:               System.out.println(x);            // 30
//9:               System.out.println(this.x);       // 30
//10:              System.out.println(B.this.x);     // 20
//11:              System.out.println(A.this.x);    // 10
//12:       } } }
//13:      public static void main(String[] args) {
//14:         A a = new A();
//15:         A.B b = a.new B();
//16:         A.B.C c = b.new C();
//17:         c.allTheX();
//18:   }}
//Да, этот код заставляет нас тоже съеживаться. У него есть два вложенных класса.
// Строка 14 создает экземпляр самого внешнего.
// Строка 15 использует неуклюжий синтаксис для создания экземпляра a B. Обратите внимание на тип A.B.
// Мы могли бы написать Bкак тип, потому что это доступно на уровне члена B. Java знает, где его искать.
// В строке 16 мы создаем экземпляр a C. На этот раз A.B.Cтип необходимо указать. Cслишком глубоко для Java,
// чтобы знать, где искать. Затем строка 17 вызывает метод on c.
//Строки 8 и 9 - это тип кода, который мы привыкли видеть.
// Они ссылаются на переменную экземпляра в текущем классе - который объявлен в строке 6, чтобы быть точным.
// Линия 10 использует thisособым образом. Мы все еще хотим переменную экземпляра.
// Но на этот раз мы хотим получить значение Bкласса, которое является переменной в строке 4.
// Строка 11 делает то же самое для класса A, получая переменную из строки 2.